---
title: Components
sidebar:
  order: 30
---

import Properties from "@components/SchemaItemProperties.astro";
import ExampleYAML from "@components/ExampleYAML.astro";
import { Tabs, TabItem } from "@astrojs/starlight/components";

The actual capabilities that Zarf Packages provided are defined within named components.

These components define what dependencies they have along with a declarative definition of how they should be deployed.

Each package can have as many components as the package creator wants but a package isn't anything without at least one component.

Fully defined examples of components can be found in the [examples section](/ref/examples) of the documentation.

{/* 
## What can be Packaged?

The following types of software can be rolled into a Zarf Package:

- Container images + artifacts: to serve images and OCI artifacts for clusters and other consumers to pull.
- [Repositories](../examples/git-data/README.md): to serve as the git-based "source of truth" for GitOps application deployments.
- Pre-compiled binaries: to provide the software necessary to start and support a cluster.
- [Component actions](3-create-a-zarf-package/7-component-actions.md): to support scripts and commands that run at various stages of the Zarf [package create lifecycle](./3-create-a-zarf-package/5-package-create-lifecycle.md), and [package deploy lifecycle](./4-deploy-a-zarf-package/1-package-deploy-lifecycle.md).
- Helm charts, kustomizations, and other K8s manifests: to apply to a Kubernetes cluster.
- [Data injections](../examples/kiwix/README.md): to declaratively inject data into running containers in a Kubernetes cluster.
*/}

## Common Component Fields

There are certain fields that will be common across all component definitions. These fields are:

<Properties
  item="ZarfComponent"
  invert
  include={["files", "charts", "manifests", "images", "repos", "dataInjections", "extensions", "scripts", "actions"]}
/>

### Actions

<Properties item="ZarfComponent" include={["actions"]} />

Component actions are explored in the [component actions documentation](/create-a-package/component-actions).

### Files

<Properties item="ZarfComponent" include={["files"]} />

Files can be:

- Relative paths to either a file or directory (from the `zarf.yaml` file)
- A remote URL (http/https)
- Verified using the `shasum` field for data integrity (optional and only available for files)

#### File Examples

<Tabs>
  <TabItem label="Local">
    <ExampleYAML
      src={import("../../../../../examples/component-actions/zarf.yaml?raw")}
      component="on-deploy-with-template-use-of-variable"
    />
  </TabItem>
  <TabItem label="Remote with SHA sums">
    <ExampleYAML src={import("../../../../../packages/distros/k3s/zarf.yaml?raw")} component="k3s" />
  </TabItem>
</Tabs>

### Helm Charts

<Properties item="ZarfComponent" include={["charts"]} />

Charts using the `localPath` key can be:

- Relative paths to either a file or directory (from the `zarf.yaml` file)

Charts using the `url` key can be:

- A remote URL (http/https) to a Git repository
- A remote URL (oci://) to an OCI registry
- A remote URL (http/https) to a Helm repository

:::note

To use a private Helm repository the repo must be added to Helm. You can add a repo to Helm with the [`helm repo add`](https://helm.sh/docs/helm/helm_repo_add/) command or the internal [`zarf tools helm repo add`](../2-the-zarf-cli/100-cli-commands/zarf_tools_helm_repo_add.md) command.

:::

#### Chart Examples

<ExampleYAML src={import("../../../../../examples/helm-charts/zarf.yaml?raw")} component="demo-helm-charts" />

### Kubernetes Manifests

<Properties item="ZarfComponent" include={["manifests"]} />

Manifests under the `files` key can be:

- Relative paths to a Kubernetes manifest file (from the `zarf.yaml` file)
- Verified using the `url@shasum` syntax for data integrity (optional and only for remote URLs)

Manifests under the `kustomizations` key can be:

- Any valid Kustomize reference both local and [remote](https://github.com/kubernetes-sigs/kustomize/blob/master/../../../../../examples/remoteBuild.md) (ie. anything you could do a `kustomize build` on)

:::note

Zarf dynamically generates a Helm Chart from the named manifest entries that you specify. This means that any given set of files under a manifest entry will be applied according to [Helm Chart template and manifest install ordering](https://github.com/helm/helm/blob/main/pkg/releaseutil/manifest_sorter.go#L78) and not necessarily in the order that files are declared. If ordering is important, consider moving each file into its own manifest entry in the `manifests` array.

:::

#### Manifest Examples

<Tabs>
<TabItem label="Local">
<ExampleYAML src={import('../../../../../examples/manifests/zarf.yaml?raw')} component="httpd-local" />
</TabItem>
<TabItem label="Remote">
<ExampleYAML src={import ('../../../../../examples/manifests/zarf.yaml?raw')} component="nginx-remote" />
</TabItem>
<TabItem label="Kustomizations">

:::note

Kustomizations are handled a bit differently than normal manifests in that Zarf will automatically run `kustomize build` on them during `zarf package create`, thus rendering the Kustomization into a single manifest file. This prevents needing to grab any remote Kustomization resources during `zarf package deploy` but also means that any Zarf [`variables`](../../../../../examples/../../variables/README.md#deploy-time-variables-and-constants) will only apply to the rendered manifest not the `kustomize build` process.

:::

<ExampleYAML src={import('../../../../../examples/manifests/zarf.yaml?raw')} component="podinfo-kustomize" />
</TabItem>
</Tabs>

### Container Images

<Properties item="ZarfComponent" include={["images"]} />

Images can either be discovered manually, or automatically by using [`zarf dev find-images`](../2-the-zarf-cli/100-cli-commands/zarf_dev_find-images.md).

:::note

`zarf dev find-images` will find images for most standard manifests, kustomizations, and helm charts, however some images cannot be discovered this way as some upstream resources (like operators) may bury image definitions inside. For these images, `zarf dev find-images` also offers support for the draft [Helm Improvement Proposal 15](https://github.com/helm/community/blob/main/hips/hip-0015.md) which allows chart creators to annotate any hidden images in their charts along with the [values conditions](https://github.com/helm/community/issues/277) that will cause those images to be used.

:::

#### Image Examples

<ExampleYAML src={import("../../../../../examples/podinfo-flux/zarf.yaml?raw")} component="flux" />

### Git Repositories

The [`git-data`](/../../../../../examples/git-data/) example provides an in-depth explanation of how to include Git repositories in your Zarf package to be pushed to the internal/external Git server.

The [`podinfo-flux`](/../../../../../examples/podinfo-flux/) example showcases a simple GitOps workflow using Flux and Zarf.

<Properties item="ZarfComponent" include={["repos"]} />

#### Repository Examples

<Tabs>
  <TabItem label="Full Mirror">
    <ExampleYAML src={import("../../../../../examples/git-data/zarf.yaml?raw")} component="full-repo" />
  </TabItem>
  <TabItem label="Specific Tag">
    <ExampleYAML src={import("../../../../../examples/git-data/zarf.yaml?raw")} component="specific-tag" />
  </TabItem>
  <TabItem label="Specific Branch">
    <ExampleYAML src={import("../../../../../examples/git-data/zarf.yaml?raw")} component="specific-branch" />
  </TabItem>
  <TabItem label="Specific Hash">
    <ExampleYAML src={import("../../../../../examples/git-data/zarf.yaml?raw")} component="specific-hash" />
  </TabItem>
</Tabs>

### Data Injections

<Properties item="ZarfComponent" include={["dataInjections"]} />

<ExampleYAML src={import("../../../../../examples/kiwix/zarf.yaml?raw")} component="kiwix-serve" />

### Component Imports

<Properties item="ZarfComponent" include={["import"]} />

<Tabs>
  <TabItem label="Local Path">
    <ExampleYAML src={import("../../../../../examples/composable-packages/zarf.yaml?raw")} component="local-games-path" />
  </TabItem>
  <TabItem label="OCI URL">
    <ExampleYAML src={import("../../../../../examples/composable-packages/zarf.yaml?raw")} component="oci-games-url" />
  </TabItem>
</Tabs>

:::note

During composition, Zarf will merge the imported component with the component that is importing it. This means that if the importing component defines a field that the imported component also defines, the value from the importing component will be used and override.

This process will also merge `variables` and `constants` defined in the imported component's `zarf.yaml` with the importing component. The same override rules apply here as well.

:::

### Extensions

<Properties item="ZarfComponent" include={["extensions"]} />

<ExampleYAML src={import("../../../../../examples/big-bang/zarf.yaml?raw")} component="bigbang" />

## Deploying Components

When deploying a Zarf package, components are deployed in the order they are defined in the `zarf.yaml`.

The `zarf.yaml` configuration for each component also defines whether the component is 'required' or not. 'Required' components are always deployed without any additional user interaction while optional components are printed out in an interactive prompt asking the user if they wish to the deploy the component.

If you already know which components you want to deploy, you can do so without getting prompted by passing the components as a comma-separated list to the `--components` flag during the deploy command.

```bash
# deploy all required components, prompting for optional components and variables
$ zarf package deploy ./path/to/package.tar.zst

# deploy all required components, ignoring optional components and variable prompts
$ zarf package deploy ./path/to/package.tar.zst --confirm

# deploy optional-component-1 and optional-component-2 components whether they are required or not
$ zarf package deploy ./path/to/package.tar.zst --components=optional-component-1,optional-component-2
```

:::tip

You can deploy components in a package using globbing as well. The following would deploy all components regardless of optional status:

```bash
# deploy optional-component-1 and optional-component-2 components whether they are required or not
$ zarf package deploy ./path/to/package.tar.zst --components=*
```

If you have any `default` components in a package definition you can also exclude those from the CLI with a leading dash (`-`) (similar to how you can exclude search terms in a search engine).

```bash
# deploy optional-component-1 but exclude default-component-1
$ zarf package deploy ./path/to/package.tar.zst --components=optional-component-1,-default-component-1
```

:::
